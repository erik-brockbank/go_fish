unique(data$game_id)
unique_game_data = get_unique_game_data(data)
# Get ACF data
acf_agg = get_game_acf(unique_game_data, MAX_LAG)
# Plot ACF data
plot_acf(acf_agg)
# 3. What kind of streaks are needed to produce significant auto-correlations?
k = 20
# 3. What kind of streaks are needed to produce significant auto-correlations?
streak_length = 20
sample_game = sample(c(-1, 0, 1), 300, replace = T)
sample_game
# randomly set first streak_length games to be wins and middle streak_length games to be losses
sample_game[1:streak_length] = 1
sample_game[101:(100 + streak_length)] = -1
acf(sample_game)
get_sample_game = function(rounds) {
sample(c(-1, 0, 1), rounds, replace = T)
}
sample_game = get_sample_game(300)
# Function to add a winning and losing streak of length `streak_length` to the `sample_game`
add_game_streaks = function(sample_game, streak_length) {
# randomly set first streak_length games to be wins and middle streak_length games to be losses
sample_game[1:streak_length] = 1
sample_game[101:(100 + streak_length)] = -1
return(sample_game)
}
sample_game = add_game_streaks(sample_game)
sample_game = add_game_streaks(sample_game, streak_length)
sample_game
acf(sample_game)
unique_game_data
# Function to generate a sample set of `rounds` outcomes
get_sample_game = function(rounds) {
sample(c("loss", "tie", "win"), rounds, replace = T)
}
# Function to add a winning and losing streak of length `streak_length` to the `sample_game`
add_game_streaks = function(sample_game, streak_length) {
# randomly set first streak_length games to be wins and middle streak_length games to be losses
sample_game[1:streak_length] = "win"
sample_game[101:(100 + streak_length)] = "loss"
return(sample_game)
}
# 3. What kind of streaks are needed to produce significant auto-correlations?
streak_length = 20
sample_game = get_sample_game(300)
sample_game
sample_game = add_game_streaks(sample_game, streak_length)
sample_game
unique_game_data
unique_game_data
sample_df = data.frame(game_id = 1, round_index = seq(1, 300), player_outcome = sample_game)
sample_df
sample_df = data.frame(game_id = 1, round_index = seq(1, 300), player_outcome = sample_game,
stringsAsFactors = F)
# acf(sample_game)
# Get ACF data
acf_sample = get_game_acf(sample_df, MAX_LAG)
acf_sample
# Plot ACF data
plot_acf(acf_sample)
ROUNDS = 300
streak_pct = (2 * streak_length) / ROUNDS
streak_pct
# Function to generate acf of simulated games for `n_particpants` playing `rounds`
get_sample_acf = function(streak_length, rounds, n_participants) {
sample_df = data.frame(game_id = numeric(), round_index = numeric(), player_outcome = character(),
stringsAsFactors = F)
sample_game = get_sample_game(rounds)
sample_game = add_game_streaks(sample_game, streak_length)
sample_df = rbind(sample_df,
data.frame(game_id = 1, round_index = seq(1, rounds), player_outcome = sample_game,
stringsAsFactors = F))
return(sample_df)
}
# Select only a single player within each dyad (their opponent should have identical acf)
unique(data$game_id)
# Select only a single player within each dyad (their opponent should have identical acf)
length(unique(data$game_id))
sample_acf_data = get_sample_acf(streak_length, ROUNDS, length(unique(data$game_id)))
sample_acf_data
# Get ACF data
acf_sample = get_game_acf(sample_acf_data, MAX_LAG)
acf_sample
# Plot ACF data
plot_acf(acf_sample)
n_participants
n_participants = 58
seq(1, n_participants)
for (game in seq(1, n_participants)) {print(game)}
# Function to generate acf of simulated games for `n_particpants` playing `rounds`
get_sample_acf = function(streak_length, rounds, n_participants) {
sample_df = data.frame(game_id = numeric(), round_index = numeric(), player_outcome = character(),
stringsAsFactors = F)
for (game in seq(1, n_participants)) {
sample_game = get_sample_game(rounds)
sample_game = add_game_streaks(sample_game, streak_length)
sample_df = rbind(sample_df,
data.frame(game_id = game, round_index = seq(1, rounds), player_outcome = sample_game,
stringsAsFactors = F))
}
return(sample_df)
}
sample_acf_data = get_sample_acf(streak_length, ROUNDS, 2)
sample_acf_data
# Get ACF data
acf_sample = get_game_acf(sample_acf_data, MAX_LAG)
acf_sample
# Plot ACF data
plot_acf(acf_sample)
sample_acf_data = get_sample_acf(streak_length, ROUNDS, 10)
# Get ACF data
acf_sample = get_game_acf(sample_acf_data, MAX_LAG)
# Plot ACF data
plot_acf(acf_sample)
sample_acf_data = get_sample_acf(streak_length, ROUNDS, length(unique(data$game_id)))
# Get ACF data
acf_sample = get_game_acf(sample_acf_data, MAX_LAG)
# Plot ACF data
plot_acf(acf_sample)
# 3. What kind of streaks are needed to produce significant auto-correlations?
streak_length = 10
streak_pct = (2 * streak_length) / ROUNDS
streak_pct
# 3. What kind of streaks are needed to produce significant auto-correlations?
streak_length = 20
streak_pct = (2 * streak_length) / ROUNDS
sample_acf_data = get_sample_acf(streak_length, ROUNDS, 100)
# Get ACF data
acf_sample = get_game_acf(sample_acf_data, MAX_LAG)
# Plot ACF data
plot_acf(acf_sample)
streak_pct
# 3. What kind of streaks are needed to produce significant auto-correlations?
streak_length = 15
streak_pct = (2 * streak_length) / ROUNDS
sample_acf_data = get_sample_acf(streak_length, ROUNDS, 100)
# Get ACF data
acf_sample = get_game_acf(sample_acf_data, MAX_LAG)
# Plot ACF data
plot_acf(acf_sample)
# 3. What kind of streaks are needed to produce significant auto-correlations?
streak_length = 25
streak_pct = (2 * streak_length) / ROUNDS
streak_pct
# 3. What kind of streaks are needed to produce significant auto-correlations?
streak_length = 30
streak_pct = (2 * streak_length) / ROUNDS
streak_pct
sample_acf_data = get_sample_acf(streak_length, ROUNDS, 100)
# Get ACF data
acf_sample = get_game_acf(sample_acf_data, MAX_LAG)
# Plot ACF data
plot_acf(acf_sample)
# 3. What kind of streaks are needed to produce significant auto-correlations?
streak_length = 15
streak_pct = (2 * streak_length) / ROUNDS
streak_pct
sample_acf_data = get_sample_acf(streak_length, ROUNDS, 100)
# Get ACF data
acf_sample = get_game_acf(sample_acf_data, MAX_LAG)
# Plot ACF data
plot_acf(acf_sample)
# 3. What kind of streaks are needed to produce significant auto-correlations?
streak_length = 30
streak_pct = (2 * streak_length) / ROUNDS
streak_pct
sample_acf_data = get_sample_acf(streak_length, ROUNDS, 100)
# Get ACF data
acf_sample = get_game_acf(sample_acf_data, MAX_LAG)
# Plot ACF data
plot_acf(acf_sample)
sample_acf_data = get_sample_acf(streak_length, ROUNDS, 58)
# 3. What kind of streaks are needed to produce significant auto-correlations?
streak_length = 15
streak_pct = (2 * streak_length) / ROUNDS
streak_pct
sample_acf_data = get_sample_acf(streak_length, ROUNDS, 58)
# Get ACF data
acf_sample = get_game_acf(sample_acf_data, MAX_LAG)
# Plot ACF data
plot_acf(acf_sample)
# 3. What kind of streaks are needed to produce significant auto-correlations?
streak_length = 30
streak_pct = (2 * streak_length) / ROUNDS
sample_acf_data = get_sample_acf(streak_length, ROUNDS, 58)
# Get ACF data
acf_sample = get_game_acf(sample_acf_data, MAX_LAG)
# Plot ACF data
plot_acf(acf_sample)
# 3. What kind of streaks are needed to produce significant auto-correlations?
streak_length = 20
streak_pct = (2 * streak_length) / ROUNDS
streak_pct
# 3. What kind of streaks are needed to produce significant auto-correlations?
streak_length = 25
streak_pct = (2 * streak_length) / ROUNDS
streak_pct
# 3. What kind of streaks are needed to produce significant auto-correlations?
streak_length = 24
streak_pct = (2 * streak_length) / ROUNDS
streak_pct
# 3. What kind of streaks are needed to produce significant auto-correlations?
streak_length = 23
streak_pct = (2 * streak_length) / ROUNDS
streak_pct
# 3. What kind of streaks are needed to produce significant auto-correlations?
streak_length = 22
streak_pct = (2 * streak_length) / ROUNDS
streak_pct
# 3. What kind of streaks are needed to produce significant auto-correlations?
streak_length = 23
streak_pct = (2 * streak_length) / ROUNDS
streak_pct
sample_acf_data = get_sample_acf(streak_length, ROUNDS, 58)
# Get ACF data
acf_sample = get_game_acf(sample_acf_data, MAX_LAG)
# Plot ACF data
plot_acf(acf_sample)
# 3. What kind of streaks are needed to produce significant auto-correlations?
streak_length = 30
streak_pct = (2 * streak_length) / ROUNDS
streak_pct
sample_acf_data = get_sample_acf(streak_length, ROUNDS, 58)
# Get ACF data
acf_sample = get_game_acf(sample_acf_data, MAX_LAG)
# Plot ACF data
plot_acf(acf_sample)
# 3. What kind of streaks are needed to produce significant auto-correlations?
streak_length = 15
streak_pct = (2 * streak_length) / ROUNDS
sample_acf_data = get_sample_acf(streak_length, ROUNDS, 58)
# Get ACF data
acf_sample = get_game_acf(sample_acf_data, MAX_LAG)
# Plot ACF data
plot_acf(acf_sample)
# Function to add a winning and losing streak of length `streak_length` to the `sample_game`
add_game_streaks = function(sample_game, streak_length) {
# randomly set first streak_length games to be wins and middle streak_length games to be losses
sample_game[1:streak_length] = "win"
# sample_game[101:(100 + streak_length)] = "loss"
sample_game[101:(100 + streak_length)] = "win"
return(sample_game)
}
# 3. What kind of streaks are needed to produce significant auto-correlations?
streak_length = 15
streak_pct = (2 * streak_length) / ROUNDS
sample_acf_data = get_sample_acf(streak_length, ROUNDS, 58)
# Get ACF data
acf_sample = get_game_acf(sample_acf_data, MAX_LAG)
# Plot ACF data
plot_acf(acf_sample)
# 3. What kind of streaks are needed to produce significant auto-correlations?
streak_length = 30
streak_pct = (2 * streak_length) / ROUNDS
sample_acf_data = get_sample_acf(streak_length, ROUNDS, 58)
# Get ACF data
acf_sample = get_game_acf(sample_acf_data, MAX_LAG)
# Plot ACF data
plot_acf(acf_sample)
rm(list=ls())
setwd("/Users/erikbrockbank/web/vullab/data_analysis/rps_data/")
source('02_data_analysis-transition_entropy.R') # NB: nested sourcing here. this sources 01 which sources 00
# Chi-squared comparison of empirical and null counts
emp_win_count_bins = win_count_diff_empirical %>%
group_by(bin = cut(win_diff, breaks = seq(0, 60, by = 10), include.lowest = TRUE)) %>%
summarise(n = n())
emp_win_count_bins
null_win_count_bins = win_count_diff_null %>%
filter(win_diff <= max(win_count_diff_empirical$win_diff)) %>%
group_by(bin = cut(win_diff, breaks = seq(0, 60, by = 10), include.lowest = TRUE)) %>%
summarise(n = n()) %>%
mutate(prop = n / sum(n))
null_win_count_bins
source('02_data_analysis-transition_entropy.R') # NB: nested sourcing here. this sources 01 which sources 00
source('02_data_analysis-transition_entropy.R') # NB: nested sourcing here. this sources 01 which sources 00
source('02_data_analysis-transition_entropy.R') # NB: nested sourcing here. this sources 01 which sources 00
warnings()
# Globals
# number of RPS rounds played in each complete game
RPS_ROUNDS = 300
# Score differential outcome for each move combination (player in rows, opponent in cols)
OUTCOME_MATRIX = matrix(c(0, -1, 1, 1, 0, -1, -1, 1, 0), nrow = 3, byrow = T)
rownames(OUTCOME_MATRIX) = c("rock", "paper", "scissors")
colnames(OUTCOME_MATRIX) = c("opp_rock", "opp_paper", "opp_scissors")
# Get maximum expected win count differential based on move probabilities in player_summary
get_expected_win_count_differential_moves = function(player_summary) {
player_summary %>%
group_by(player_id) %>%
summarize(max_util = max(
rowSums(matrix(rep(pmove, 3), nrow = 3, byrow = T) * OUTCOME_MATRIX))) %>%
mutate(win_diff = max_util * RPS_ROUNDS)
}
# Get maximum expected win count differential based on transition probabilities in player_trans_summary
# TODO can we unify this with the above? only difference is column name (pmove, p.transition)
get_expected_win_count_differential_trans = function(player_summary) {
player_summary %>%
group_by(player_id) %>%
summarize(max_util = max(
rowSums(matrix(rep(p.transition, 3), nrow = 3, byrow = T) * OUTCOME_MATRIX))) %>%
mutate(win_diff = max_util * RPS_ROUNDS)
}
# Get maximum expected win count differential based on distribution of moves given opponent's previous move
get_expected_win_count_differential_opponent_prev_move = function(player_summary) {
player_summary %>%
group_by(player_id, opponent.prev.move) %>%
# get expected value for each previous move conditional distribution
summarize(max_util = max(
rowSums(matrix(rep(pmove_opponent.prev.move, 3), nrow = 3, byrow = T) * OUTCOME_MATRIX))) %>%
# normalize expected value for each opponent previous move (uniform)
mutate(max_util_norm = max_util * (1 / 3)) %>%
# get overall expected value by summing over (normalized) expected values for each previous move
group_by(player_id) %>%
summarize(win_diff = sum(max_util_norm) * RPS_ROUNDS)
}
# Get maximum expected win count differential based on distribution of moves given player's previous move
get_expected_win_count_differential_prev_move = function(player_summary) {
player_summary %>%
group_by(player_id, prev.move) %>%
# get expected value for each previous move conditional distribution
summarize(max_util = max(
rowSums(matrix(rep(pmove_prev.move, 3), nrow = 3, byrow = T) * OUTCOME_MATRIX))) %>%
# normalize expected value for each previous move (uniform)
mutate(max_util_norm = max_util * (1 / 3)) %>%
# get overall expected value by summing over (normalized) expected values for each previous move
group_by(player_id) %>%
summarize(win_diff = sum(max_util_norm) * RPS_ROUNDS)
}
# Get maximum expected win count differential based on distribution of transitions given player's previous outcome
get_expected_win_count_differential_prev_outcome = function(player_summary) {
player_summary %>%
group_by(player_id, prev.outcome) %>%
# get expected value for each previous move conditional distribution
summarize(max_util = max(
rowSums(matrix(rep(p.transition.outcome, 3), nrow = 3, byrow = T) * OUTCOME_MATRIX))) %>%
# normalize expected value for each previous outcome (uniform)
mutate(max_util_norm = max_util * (1 / 3)) %>%
# get overall expected value by summing over (normalized) expected values for each previous move
group_by(player_id) %>%
summarize(win_diff = sum(max_util_norm) * RPS_ROUNDS)
}
# Get maximum expected win count differential based on distribution of moves given player's previous two moves
get_expected_win_count_differential_prev_2moves = function(player_summary) {
player_summary %>%
group_by(player_id, prev.move, prev.move2) %>%
# get expected value for each previous move conditional distribution
summarize(max_util = max(
rowSums(matrix(rep(pmove_2prev.move, 3), nrow = 3, byrow = T) * OUTCOME_MATRIX))) %>%
# normalize expected value for each previous two-move combination (uniform)
mutate(max_util_norm = max_util * (1 / 9)) %>%
# get overall expected value by summing over (normalized) expected values for each previous move
group_by(player_id) %>%
summarize(win_diff = sum(max_util_norm) * RPS_ROUNDS)
}
# Get maximum expected win count differential based on distribution of moves given player's previous move, opponent's previous move
get_expected_win_count_differential_prev_move_opponent_prev_move = function(player_summary) {
player_summary %>%
group_by(player_id, prev.move, opponent.prev.move) %>%
# get expected value for each previous move conditional distribution
summarize(max_util = max(
rowSums(matrix(rep(pmove_prev.move_opponent.prev.move, 3), nrow = 3, byrow = T) * OUTCOME_MATRIX))) %>%
# normalize expected value for each previous two-move combination (uniform)
mutate(max_util_norm = max_util * (1 / 9)) %>%
# get overall expected value by summing over (normalized) expected values for each previous move
group_by(player_id) %>%
summarize(win_diff = sum(max_util_norm) * RPS_ROUNDS)
}
# Get maximum expected win count differential based on distribution of moves given player's previous transition, previous outcome
get_expected_win_count_differential_prev_transition_prev_outcome = function(player_summary) {
player_summary %>%
group_by(player_id, player.prev.transition, prev.outcome) %>%
# get expected value for each previous move conditional distribution
summarize(max_util = max(
rowSums(matrix(rep(p.transition.prev.transition.prev.outcome, 3), nrow = 3, byrow = T) * OUTCOME_MATRIX))) %>%
# normalize expected value for each previous two-move combination (uniform)
mutate(max_util_norm = max_util * (1 / 9)) %>%
# get overall expected value by summing over (normalized) expected values for each previous move
group_by(player_id) %>%
summarize(win_diff = sum(max_util_norm) * RPS_ROUNDS)
}
# Get summary stats for win count differential
get_win_count_differential_summary = function(data, category) {
data %>%
summarize(
category = category,
mean_wins = mean(win_diff),
n = n(),
se = sd(win_diff) / sqrt(n),
ci_lower = mean_wins - se,
ci_upper = mean_wins + se
)
}
legend.width = 10
summary_labels = c("empirical" = str_wrap("Empirical results", legend.width),
"null_sample" = str_wrap("Random behavior", legend.width),
"move_probability" = str_wrap("Choice baserate (R/P/S)", legend.width),
"trans_probability" = str_wrap("Transition baserate (+/-/0)", legend.width),
"opponent_prev_move_probability" = str_wrap("Choice given opponent's prior choice", legend.width),
"prev_move_probability" = str_wrap("Choice given player's prior choice", legend.width),
"player_transition_prev_outcome_probability" = str_wrap("Transition given prior outcome (W/L/T)", legend.width),
"prev_2move_probability" = str_wrap("Choice given player's prior two choices", legend.width),
"prev_move_opponent_prev_move_probability" = str_wrap("Choice given player's prior choice & opponent's prior choice", legend.width),
"player_transition_prev_transition_prev_outcome_probability" = str_wrap("Transition given prior transition & prior outcome", legend.width))
summary_values_legend = c("player_transition_prev_transition_prev_outcome_probability",
"prev_move_opponent_prev_move_probability", "prev_2move_probability",
"player_transition_prev_outcome_probability",
"prev_move_probability", "opponent_prev_move_probability",
"trans_probability", "move_probability",
"null_sample",
"empirical"
)
summary_values = c(#"empirical",
#"null_sample",
"move_probability", "trans_probability",
"opponent_prev_move_probability", "prev_move_probability",
"player_transition_prev_outcome_probability",
"prev_2move_probability", "prev_move_opponent_prev_move_probability",
"player_transition_prev_transition_prev_outcome_probability")
x_values = c("empirical",
"null_sample", "move_probability", "trans_probability",
"opponent_prev_move_probability", "prev_move_probability",
"player_transition_prev_outcome_probability",
"prev_2move_probability", "prev_move_opponent_prev_move_probability",
"player_transition_prev_transition_prev_outcome_probability")
plot_win_differential_summary = function(win_diff_summary, win_diff_empirical, win_diff_null) {
win_diff_empirical_summary = get_win_count_differential_summary(win_diff_empirical, "empirical")
win_diff_summary %>%
ggplot(aes(x = factor(category,
# TODO extract these from the object above rather than copy-pasta
levels = summary_values),
y = mean_wins)) +
# points for expected value win count diffs
geom_point(aes(color = factor(category,
levels = summary_values)), size = 6) +
# errorbars for expected value win count diffs
geom_errorbar(aes(color = factor(category,
levels = summary_values),
ymin = ci_lower, ymax = ci_upper), width = 0.25, size = 1) +
# raw data for empirical win count diffs
geom_jitter(data = win_diff_empirical, aes(x = factor("empirical"), y = win_diff),
color = "blue", alpha = 0.5, width = 0.2, size = 4) +
geom_point(data = win_diff_empirical, aes(x = factor("empirical"), y = mean(win_diff)),
color = "red", size = 6) +
geom_errorbar(data = win_diff_empirical_summary, aes(x = factor("empirical"),
ymin = ci_lower, ymax = ci_upper),
color = "red", width = 0.25, size = 1) +
# point for mean null win count diff
geom_point(data = win_diff_null, aes(x = factor("null_sample"), y = mean(win_diff)), size = 6, color = "black") +
labs(x = "", y = "Dyad win count differential") +
ggtitle("Theoretical and empirical exploitability of player moves") +
scale_x_discrete(limits = x_values,
labels = summary_labels) +
scale_color_viridis(discrete = TRUE,
name = element_blank()) +
#labels = summary_labels,
#breaks = summary_values_legend) +
individ_plot_theme +
theme(#axis.text.x = element_blank(),
plot.title = element_text(size = 32, face = "bold"),
axis.title.y = element_text(size = 24, face = "bold"),
axis.text.x = element_text(size = 20, face = "bold", angle = 0, vjust = 1),
axis.text.y = element_text(face = "bold", size = 20),
legend.position = "none")
#coord_flip()
}
## 1. Distribution of moves (3 cells)
# get overall probability of each move (for each player)
player_summary = get.player.move.dist(data)
player_summary
# get max utility value for opponent of each player based on each player's move probabilities
player_utils = get_expected_win_count_differential_moves(player_summary)
player_utils
# plot expected win differentials based on move probability data
plot.win.differentials(player_utils, "Distribution of win count differentials", "Maximum expected (move probabilities)")
get_win_count_differential_summary(player_utils, "move_probability")
player_summary
player_summary %>%
group_by(player_id) %>%
summarize(max_util = max(
rowSums(matrix(rep(pmove, 3), nrow = 3, byrow = T) * OUTCOME_MATRIX)))
player_summary %>% filter(player_id == "0333c73a-6d1f-4cc9-afde-d0d833bc47f8") %>% select(pmove)
pmove = player_summary %>% filter(player_id == "0333c73a-6d1f-4cc9-afde-d0d833bc47f8") %>% select(pmove)
pmove
pmove = pmove$pmove
pmove
rep(pmove, 3)
matrix(rep(pmove, 3), nrow = 3, byrow = T)
matrix(rep(pmove, 3), nrow = 3, byrow = T) * OUTCOME_MATRIX
rowSums(matrix(rep(pmove, 3), nrow = 3, byrow = T) * OUTCOME_MATRIX)
rm(list = ls())
setwd("~/web/go_fish/analysis/")
library(tidyverse)
library(viridis)
library(patchwork)
# GLOBALS ======================================================================
# Data files
ROUND1_SUMMARY_DATA = "round1/01_go_fish_meta.csv"
ROUND1_TRIAL_DATA = "round1/02_go_fish_trials.csv"
ROUND1_GENERATION_RESP_DATA = "round1/03_go_fish_generation_free_resp.csv"
ROUND1_GENERATION_JUDG_DATA = "round1/04_go_fish_generation_judgment.csv"
ROUND1_EVAL_DATA = "round1/05_go_fish_evaluation.csv"
ROUND1_MEMORY_DATA = "round1/06_go_fish_memory.csv"
ROUND2_SUMMARY_DATA = "round2/01_go_fish_meta.csv"
ROUND2_TRIAL_DATA = "round2/02_go_fish_trials.csv"
ROUND2_GENERATION_RESP_DATA = "round2/03_go_fish_generation_free_resp.csv"
ROUND2_GENERATION_JUDG_DATA = "round2/04_go_fish_generation_judgment.csv"
ROUND2_EVAL_DATA = "round2/05_go_fish_evaluation.csv"
ROUND2_MEMORY_DATA = "round2/06_go_fish_memory.csv"
GENERATION_RESP_DATA_CODED = "free_response_combined.csv"
# Data labels
RULE_EVAL_LABELS = c("TRUE" = "Target rule", "FALSE" = "All other rules")
DISTRACTOR_LABELS = c("TRUE" = "Target rule", "FALSE" = "Distractor rule")
